using Noggog;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Synthesis.Settings;
using Mutagen.Bethesda.WPF.Reflection.Attributes;
using System.Collections.Generic;
using System.Linq;
using log4net;
using System.IO;
using ArmorDistributor.Utils;
using Newtonsoft.Json.Linq;
using System;

namespace ArmorDistributor.Config
{
    public class UserSettings
    {
        [Ignore]
        private static readonly ILog Logger = LogManager.GetLogger(typeof(UserSettings));

        [MaintainOrder]
        [JsonDiskName("PatcherPrefix")]
        [SettingName("Patcher Plugins Prefix: ")]
        [SynthesisTooltip("Prefix for the plugins generated by the patcher")]
        public string PatcherPrefix = string.Empty;

        [MaintainOrder]
        [JsonDiskName("DefaultOutfitPercentage")]
        [SettingName("Distribute Default Outfits By: ")]
        [SynthesisTooltip("Along with moded outfits, distribute default outfits as well by mentioned percentage.")]
        public int DefaultOutfitPercentage = 10;

        [MaintainOrder]
        [JsonDiskName("FilterUniqueNPC")]
        [SettingName("Filter Unique NPC: ")]
        [SynthesisTooltip("Outfits will not be assigned to unique NPCs when seleted")]
        public bool FilterUniqueNPC = false;


        [MaintainOrder]
        [JsonDiskName("CreateOutfitsOnly")]
        [SettingName("Create Outfits Only: ")]
        [SynthesisTooltip("This will only create new outfits and will not assigned to NPC")]
        public bool CreateOutfitsOnly = false;

        [MaintainOrder]
        [JsonDiskName("AssignOutfits")]
        [SettingName("Assign Outfits:")]
        [SynthesisTooltip("Outfits will be assigned to NPC")]
        public bool AssignOutfits = true;

        [MaintainOrder]
        [JsonDiskName("SkipGuardDistribution")]
        [SettingName("Skip Guard Distribution: ")]
        [SynthesisTooltip("Distribute armors to the guards")]
        public bool SkipGuardDistribution = true;

        [MaintainOrder]
        [JsonDiskName("SkipSluttyOutfit")]
        [SettingName("Skip Slutty Outfits: ")]
        [SynthesisTooltip("When selected, Patcher will try to skip slutty armors")]
        public bool SkipSluttyOutfit = true;

        [MaintainOrder]
        [JsonDiskName("CreateBashPatch")]
        [SettingName("Bash Patch For Leveled Lists: ")]
        [SynthesisTooltip("Outfits will not be assigned to unique NPCs when selected")]
        public bool CreateBashPatch = true;

        [MaintainOrder]
        [JsonDiskName("ResolveOutfitConflicts")]
        [SettingName("Resolve Outfit Conflicts: ")]
        [SynthesisTooltip("Resolve outfit conflicts with armor mods.\nUsing this will make sure that outfits from both mods (armor mods and loadorder loosing mod) are shown.")]
        public bool ResolveOutfitConflicts = true;

        [MaintainOrder]
        [JsonDiskName("DistributeWeapons")]
        [SettingName("Distribute Weapons: ")]
        [SynthesisTooltip("Distribute Weapons along with outfit. Note:- This is very slow")]
        public bool DistributeWeapons = true;

        [MaintainOrder]
        [JsonDiskName("CreateESLs")]
        [SettingName("Create ESLs: ")]
        [SynthesisTooltip("Generated patches in form of ESLs")]
        public bool CreateESLs = true;

        [MaintainOrder]
        [JsonDiskName("DumpDebugData")]
        [SettingName("Dump Debug Data: ")]
        [SynthesisTooltip("Data will help in debugging the NPC related information")]
        public bool DumpDebugData = true;

        [MaintainOrder]
        [JsonDiskName("MinimumNpcForOutfit")]
        [SettingName("Minimum Npcs For Outfit: ")]
        [SynthesisTooltip("Only outfits assigned to minimum number of NPCs will be patched")]
        public int MinimumNpcForOutfit = 0;

        [MaintainOrder]
        [JsonDiskName("NPCToSkip")]
        [SettingName("Skip NPCs: ")]
        [SynthesisTooltip("These npcs will be skipped")]
        public HashSet<FormKey> NPCToSkip = new();

        [MaintainOrder]
        [JsonDiskName("ModsToSkip")]
        [SettingName("Skip Mods: ")]
        [SynthesisTooltip("Select the mods which you don't want to use in patcher or creating issues while patching")]
        public HashSet<ModKey> ModsToSkip = new();

        [MaintainOrder]
        [JsonDiskName("ModsToPatch")]
        [SettingName("Mods To Patch: ")]
        [SynthesisTooltip("Select the mods from which NPCs will use new armors")]
        public HashSet<ModKey> ModsToPatch = new();

        [MaintainOrder]
        [JsonDiskName("SleepingOutfit")]
        [SettingName("Sleeping Outfits: ")]
        [SynthesisTooltip("Select the mods from which NPCs will use new sleeping outfits. \nNote: Only one piece armor will be selected for now. \nHard Requirements: (Sleep Tight SE or Immersive Indoor Attire and Etiquette)")]
        public HashSet<ModKey> SleepingOutfit = new();

        [Ignore]
        [MaintainOrder]
        [JsonDiskName("SwimmingOutfit")]
        [SettingName("Swimming Outfits: ")]
        [SynthesisTooltip("Select the mods from which NPCs will use new swimming outfits. \nNote: Only one piece armor will be selected for now. \nHard Requirements: (Immersive Indoor Attire and Etiquette or sleep or swim attire)")]
        public HashSet<ModKey> SwimmingOutfit = new();

        [MaintainOrder]
        [SettingName("Armor Mods: ")]
        [SynthesisTooltip("Select the armor mods and the outfit category.\nIf category is not selected the mod will use Generic Category.\nFor Generic category, outfit will be created based on the armor material type.\n\n" +
            "Patcher will try to select some armor mods and assign those categories. \nYou should check this list and make sure everything is correct")]
        public List<ModCategory> PatchableArmorMods = new();

        [Ignore]
        [JsonDiskName("ArmorMods")]
        public Dictionary<string, List<string>>? ArmorMods = new();

        public UserSettings()
        {
            string exeLoc = Directory.GetParent(System.Reflection.Assembly.GetAssembly(typeof(UserSettings)).Location).FullName;
            string ConfigFile = Path.Combine(exeLoc, "data", "config", "UserSettings.json");
            JObject data = JObject.Parse(File.ReadAllText(ConfigFile));

            //if (Settings.DefaultUserSettings != null) {
            var order = Program.PatcherEnv.LoadOrder;
            if (PatcherPrefix == string.Empty)
                PatcherPrefix = data["PatcherPrefix"].ToString();
            Settings.PatcherSettings.PatcherPrefix = PatcherPrefix;

            // Mods to Skip
            if (ModsToSkip == null || !ModsToSkip.Any())
                ModsToSkip = data["ModsToSkip"]
                    .Select(x => ModKey.FromNameAndExtension(x.ToString()))
                    .Where(x => order.ContainsKey(x))
                    .ToHashSet();

            // Swimming Outfit
            if (SwimmingOutfit == null || !SwimmingOutfit.Any())
                SwimmingOutfit = data["SwimmingOutfit"]
                    .Select(x => ModKey.FromNameAndExtension(x.ToString()))
                    .Where(x => order.ContainsKey(x))
                    .ToHashSet();

            // Sleeping Outfit
            if (SleepingOutfit == null || !SleepingOutfit.Any())
                SleepingOutfit = data["SleepingOutfit"]
                    .Select(x => ModKey.FromNameAndExtension(x.ToString()))
                    .Where(x => order.ContainsKey(x))
                    .ToHashSet();


            // NPCs to Skip
            if (NPCToSkip == null || !NPCToSkip.Any())
                NPCToSkip = data["NPCToSkip"]
                    .Select(x => FormKey.Factory(x.ToString())).ToHashSet();


            // Outfit Mods to Patch
            if (ModsToPatch == null || !ModsToPatch.Any())
            {
                ModsToPatch = data["ModsToPatch"]
                    .Select(x => ModKey.FromNameAndExtension(x.ToString()))
                    .Where(x => order.ContainsKey(x) && !ModsToSkip.Contains(x))
                    .ToHashSet();
                ModsToPatch = ModsToPatch.Any() ? ModsToPatch : order.PriorityOrder
                .Where(x => x.Mod != null && (x.Mod.Npcs.Any() || x.Mod.Outfits.Any()))
                .Select(x => x.ModKey)
                .ToHashSet();
            }

            // Armor Mods
            if (PatchableArmorMods == null || !PatchableArmorMods.Any())
            {
                var mods = data["ArmorMods"].ToObject<Dictionary<string, List<string>>>();
                foreach (var pair in mods)
                {
                    if (ModKey.TryFromNameAndExtension(pair.Key, out var modKey) && Program.PatcherEnv.LoadOrder.ContainsKey(modKey))
                    {
                        List<TCategory> cats = new();
                        pair.Value.ForEach(c =>
                        {
                            if (Enum.TryParse(c, out TCategory cat)) cats.Add(cat);
                        });
                        var item = new ModCategory(modKey, cats);
                        PatchableArmorMods.Add(item);
                    }
                }
            }
            PatchableArmorMods.ForEach(mc =>
            {
                ArmorMods.GetOrAdd(mc.ArmorMod.FileName)
                .AddRange(mc.Categories.Select(x => x.ToString()).Distinct());
            });
        }
    }
}
